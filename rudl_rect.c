/* RUDL - a C library wrapping SDL for use in Ruby. Copyright (C) 2001  Danny van Bruggen */
#include "ruby.h"

void add_ruby_to_rect()
{
	rb_eval_string(
"module RUDL\n"
"	class Rect\n"
"\n"
"		attr_accessor :x, :y, :w, :h\n"
"\n"
"		def to_ary			\n"
"			[@x, @y, @w, @h]	\n"
"		end				\n"
"\n"
"		def move!( delta )		\n"
"			@x+=delta[0]		\n"
"			@y+=delta[1]		\n"
"			self			\n"
"		end\n"
"\n"
"		def move( delta )		\n"
"			clone.move!(delta)	\n"
"		end				\n"
"\n"
"		def normalize!			\n"
"			if @w<0 then		\n"
"				@x+=@w		\n"
"				@w=-@w		\n"
"			end			\n"
"			if @h<0 then\n"
"				@y+=@h\n"
"				@h=-@h\n"
"			end\n"
"			self\n"
"		end\n"
"		\n"
"		def normalize\n"
"			clone.normalize!\n"
"		end\n"
"		\n"
"		def inflate!( size )\n"
"			@x-=size[0]/2\n"
"			@y-=size[1]/2\n"
"			@w+=size[0]\n"
"			@h+=size[1]\n"
"			self\n"
"		end\n"
"		\n"
"		def inflate( size )\n"
"			clone.inflate!(size)\n"
"		end\n"
"\n"
"		def union!( other_rect )\n"
"			if other_rect.type==Array then other_rect=RUDL::Rect.new(other_rect) end\n"
"			newx = [@x, other_rect.x].min\n"
"			newy = [@y, other_rect.y].min\n"
"			@w = [@x+@w, other_rect.x+other_rect.w].max-newx\n"
"			@h = [@y+@h, other_rect.y+other_rect.h].max-newy\n"
"			@x=newx\n"
"			@y=newy\n"
"			self\n"
"		end\n"
"\n"
"		def union(other_rect)\n"
"			clone.union!(other_rect)\n"
"		end\n"
"\n"
"		def contains(thing)\n"
"			if thing.type==RUDL::Rect then thing=thing.to_ary; end\n"
"\n"
"			if thing.length==2 then\n"
"				return(thing[0]>=@x && thing[0]<=@x+@w && thing[1]>=@y && thing[1]<=@y+@h)\n"
"			elsif thing.length==4 then\n"
"				return((@x <= thing[0]) && (@y <= thing[1]) && (@x + @w >= thing[0] + thing[2]) && (@y + @h >= thing[1] + thing[3]))\n"
"			end\n"
"			raise ArgumentError.new\n"
"		end\n"
"\n"
"		def find_overlapping_rect(rects)\n"
"			rects.each {|r| \n"
"				if overlap(r) then \n"
"					return r\n"
"				end \n"
"			}\n"
"			nil\n"
"		end\n"
"\n"
"		def find_overlapping_rects(rects)\n"
"			overlaps=[]\n"
"			rects.each {|r| \n"
"				if overlap(r) then \n"
"					overlaps.push(r)\n"
"				end \n"
"			}\n"
"			overlaps\n"
"		end\n"
"\n"
"		def clip!(b)\n"
"			\n"
"			if b.type==Array then b=RUDL::Rect.new(b); end\n"
"\n"
"			# Left\n"
"			if((@x >= b.x) && (@x < (b.x+b.w))) then \n"
"				x = @x\n"
"			elsif((b.x >= @x) && (b.x < (@x+@w))) then\n"
"				x = b.x\n"
"			else\n"
"				@w=0\n"
"				@h=0\n"
"				return self\n"
"			end\n"
"\n"
"			# Right\n"
"			if(((@x+@w) > b.x) && ((@x+@w) <= (b.x+b.w)))\n"
"				w = (@x+@w) - x;\n"
"			elsif(((b.x+b.w) > @x) && ((b.x+b.w) <= (@x+@w)))\n"
"				w = (b.x+b.w) - x;\n"
"			else\n"
"				@w=0\n"
"				@h=0\n"
"				return self\n"
"			end\n"
"\n"
"			# Top\n"
"			if (@y >= b.y) && (@y < (b.y+b.h)) then\n"
"				y = @y;\n"
"			elsif (b.y >= @y) && (b.y < (@y+@h)) then\n"
"				y = b.y;\n"
"			else\n"
"				@w=0\n"
"				@h=0\n"
"				return self\n"
"			end\n"
"\n"
"			# Bottom\n"
"			if ((@y+@h) > b.y) && ((@y+@h) <= (b.y+b.h)) then\n"
"				h = (@y+@h) - y;\n"
"			elsif ((b.y+b.h) > @y) && ((b.y+b.h) <= (@y+@h)) then\n"
"				h = (b.y+b.h) - y;\n"
"			else\n"
"				@w=0\n"
"				@h=0\n"
"				return self\n"
"			end\n"
"			@x=x\n"
"			@y=y\n"
"			@w=w\n"
"			@h=h\n"
"			self\n"
"		end\n"
"\n"
"		def clip(b)\n"
"			clone.clip!(b)\n"
"		end\n"
"		\n"
"		def clamp!(argrect)\n"
"			if argrect.type==Array then argrect=RUDL::Rect.new(argrect); end\n"
"\n"
"			if @w >= argrect.w then\n"
"				x = (argrect.x+argrect.w) / 2 - @w / 2\n"
"			elsif @x < argrect.x then\n"
"				x = argrect.x\n"
"			elsif @x + @w > argrect.x + argrect.w then\n"
"				x = argrect.x + argrect.w - @w\n"
"			else\n"
"				x = @x\n"
"			end\n"
"\n"
"			if @h >= argrect.h then\n"
"				y = (argrect.y+argrect.h) / 2 - @h / 2\n"
"			elsif @y < argrect.y then\n"
"				y = argrect.y\n"
"			elsif @y + @h > argrect.y + argrect.h then\n"
"				y = argrect.y + argrect.h - @h\n"
"			else\n"
"				y = @y\n"
"			end\n"
"\n"
"			@x=x\n"
"			@y=y\n"
"			self\n"
"		end\n"
"\n"
"		def clamp(argrect)\n"
"			clone.clamp!(argrect)\n"
"		end\n"
"	end\n"
"end\n");
}
<html>
<head>
    <title>RUDL tutorial</title>
    <link rel="stylesheet" title="RUDL theme" href="rudl-tutorial.css" media="screen,projection" />
</head>
<body>


<h1>RUDL Tutorial</h1>



<h2>Introduction</h2>

<p>This is a short tutorial to RUDL, the SDL library wrapper for Ruby.
With RUDL you can create impressive games, applications, animations,
visualizations, or whatever you want. And it's quick and more importantly,
FUN to do, thanks to the ease of Ruby programming. Ruby is also fast
enough for surprisingly complex things, so prototyping your ideas that
need graphics is very easy.
</p>

<p>This tutorial assumes previous knowledge of the following:</p>
<ul>
    <li> basics of Ruby programming </li>
    <li> basics of computer graphics: what are..
        <ul>
            <li> pixels, RGB values </li>
            <li> bitmap images (a.k.a raster images) </li>
            <li> Cartesian coordinates (x,y) </li>
        </ul>
    </li>
</ul>

<p>Installing RUDL is explained in <a href="howto_install.html">another document</a>.
<p>I recommend trying out all the examples in this tutorial as they are presented,
to see what exactly they do. You can find them in the <b>docs/tutorial-files/</b> directory
ready to run. It will also help your understanding if you play with them by modifying the
code.</p>

<p>After reading this tutorial, you'll be well on your way to creating the
next RUDL masterpiece!
</p>



<h2>Opening a window or screen</h2>

<p>Naturally the first thing we'll need is a window to draw on, or the whole screen.
We need to load the RUDL library and create a DisplaySurface. A DisplaySurface
object represents an on-screen bitmap (a window or the full screen).</p>

<p>The following example (<a href="tutorial-files/window1.rbw">window1.rbw</a>)
opens a window 300 pixels wide and 200 pixels high, waits for 3 seconds, and exits.</p>
<pre>
require "RUDL"
include RUDL
include Constant

win = DisplaySurface.new([300,200])

sleep 3
</pre>

<p>First, we load the RUDL library with <code>require "RUDL"</code> (note that "RUDL" must be written in
upper case). RUDL defines its classes under the module named <code>RUDL</code>, and all constants
in module <code>RUDL::Constant</code>. We <code>include</code> those modules at the top level,
so that we won't need to type <code>RUDL::</code> in front of all RUDL class names.
</p>

<p>You'll notice that the window size, 300x200, is given as an array. All coordinates in RUDL are
expressed as [x,&nbsp;y] arrays, and rectangles are [x,&nbsp;y,&nbsp;width,&nbsp;height].
Sizes of surfaces are logically [width,&nbsp;height] arrays. RUDL defines some shortcut methods
in the Array class, most notably <code>Array#x</code> and <code>Array#y</code>. These
return the first and second element, respectively.
</p>
<blockquote>(make this a fancy "hint box"? is this hint 100% accurate?-) You can use floating point
values directly for coordinates, and they will automatically be rounded down to integers.
</blockquote>

<p><code>DisplaySurface.new</code> takes optional second and third arguments. The second
argument can contain flags, which are usually either omitted, or
<code>FULLSCREEN&nbsp;|&nbsp;HWSURFACE</code> if you want to set a full screen mode
with the given size as the resolution. The third argument is the color depth (8 for paletted
256-color, 16 for hi-color, 24 or 32 for true color).
</p>

<h3>Temporary event handler</h3>

<p>You probably noticed that our window in the previous example wasn't very responsive.
You couldn't close it, and on Windows it couldn't even be moved. We need to handle input events,
but we'll cover that subject a little later. For now, let's replace the <code>sleep&nbsp;3</code>
line with this code snippet, which simply waits for the window to be closed.
(<a href="tutorial-files/window2.rbw">window2.rbw</a>)</p>

<pre>
loop do
    event = EventQueue.wait
    break if event.is_a? QuitEvent
end
</pre>



<h2>Graphics</h2>

<p>Remember how a DisplaySurface represents an on-screen bitmap? Well, objects of class
Surface represent bitmap images in memory (off screen). We can create new surfaces of
whatever size and bit depth we want, and they'll be initially filled with black, just like
DisplaySurfaces. The DisplaySurface class inherits drawing methods from Surface, so we
can draw in the window or in a surface the exact same way.</p>

<p>While drawing lines and circles and other graphics primitives is easy, it can be difficult
to use them to create something nice. So let's start with a ready-made image to play with.
Loading images from files in RUDL is as easy as it gets: just supply a file name to
<code>Surface.load_new</code> and you get a surface containing that image! Supported
formats include PNG, JPEG, BMP, GIF and many more.</p>

<p>Let's see how to use them, with <a href="tutorial-files/image.rbw">image.rbw</a>. First
we open a window, which we've already learnt. Then we <code>fill</code> it with a gray
color: <code>[128,128,128]</code>. RGB values in RUDL are represented as [r,g,b] arrays
(or you can use hex values: 0xRRGGBBAA, where A = alpha channel value. We'll use arrays
for clarity.) </p>

<pre>
require "RUDL"
include RUDL
include Constant

win = DisplaySurface.new([300,200])
win.fill [128,128,128]
</pre>

<p>Next, we load <i>ball.gif</i> as a new surface with <code>Surface.load_new</code>.
We then blit ("paste") that surface to the window, so that its top left corner is at [90,50]:
</p>
<pre>
ball = Surface.load_new("ball.gif")
win.blit(ball, [90,50])
</pre>

<p>The loaded image has bright white pixels everywhere around the actual blue ball.
If we give the surface a <i>color key</i>, then pixels of the specified color will be skipped
(appear completely transparent) when blitting the image. So we <code>set_colorkey</code>
a white color, and then blit it again to the window, to the right side of the previous one.
</p>
<pre>
ball.set_colorkey [255,255,255]
win.blit(ball, [160,50])
</pre>

<p>There's one more cool feature I'd like to present here: the per-surface alpha value.
This makes the whole surface partially transparent, so when we blit it on top of other
graphics, we can see through it. This can also be combined with a color key, like we
do here, so the white pixels are still completely transparent. The alpha value supplied
to <code>set_alpha</code> can be from 0 (completely transparent) to 255 (completely
opaque). Let's set a 50% transparency and blit this one partially on top of the other
two balls:
</p>
<pre>
ball.set_alpha 128
win.blit(ball, [125,80])
</pre>

<p>At this point, the window still appears black. All our drawing operations have been
performed to an off-screen buffer, so that we can take our time composing it without
the user seeing the progress. Now that we're done, we call <code>update</code> to
make the changes visible:
</p>
<pre>
win.update
</pre>

<p>And finish with the same code snippet as before, which waits for the window to be
closed:
</p>
<pre>
loop do
    event = EventQueue.wait
    break if event.is_a? QuitEvent
end
</pre>

<h3>More on transparency</h3>

<p>Note that we only had to set the color key because <i>ball.gif</i> has no
transparent color. If it did, the loaded surface would automatically have its
color key set.</p>

<p>RUDL also supports per-pixel alpha values, meaning that each pixel's transparency
can be set independently. Our ball image would benefit from this: if the borders had
suitable alpha values, the ball would appear nicely smooth and antialiased both on dark and
bright backgrounds. The alpha mask is usually done in a paint program. See
<a href="tutorial-files/image2.rbw">image2.rbw</a> - it loads <i>ball.png</i>, which
has a per-pixel alpha channel, and blits it three times on different-colored backgrounds.
The borders aren't perfect when magnified because the alpha channel has been added
afterwards, but it looks good and shows the general idea. Unfortunately, per-pixel and
per-surface alpha values cannot be combined.</p>



<h2>Drawing primitives</h2>

<p>Let's look at drawing graphics primitives such as pixels, lines, and filled rectangles,
as well as blitting parts of the image. (<a href="tutorial-files/drawing.rbw">drawing.rbw</a>)</p>

<p>First load RUDL:
</p>
<pre>
require "RUDL"
include RUDL
include Constant
</pre>

<p>Then we open a window and set its title text with <code>set_caption</code> :</p>
<pre>
win = DisplaySurface.new([260,200])
win.set_caption "RUDL gfx example"
</pre>

<p>Let's fill the window completely with a gray green color, and on top of that, a gray
blue filled box whose top left corner is at [20,20] and that is 220x160 pixels in size:</p>
<pre>
win.fill [128,160,128]
win.fill [128,128,160], [20,20,220,160]
</pre>

<p>For readability, we'll assign the RGB values for black and white to variables of the same names.
Then, we plot a white pixel at [30,30]. Lastly, we demonstrate using the handy <code>[]</code>
and <code>[]=</code> methods to read and write single pixels, to copy the pixel at [30,30] to
[40,40]. (Note that <code>plot</code> is an alias for <code>[]=</code>)
</p>
<pre>
white = [255,255,255]
black = [0,0,0]

win.plot [30,30], white
win[40,40] = win[30,30]
</pre>

<p>Next, we draw two lines, specifying the starting and ending coordinates and the color:
</p>
<pre>
win.line [70,60], [90,90], black
win.line [90,90], [120,100], black
</pre>

<p>Draw a white 30x30 rectangle at 80,30. Also, draw a 10x3 rectangle, which will have
a one-pixel-thick interior, since the one-pixel-thick borders are included in the size:
</p>
<pre>
win.rectangle [80,30,30,30], white
win.rectangle [90,50,10,3], white
</pre>

<p>And now for the big finale. First, we create an (off-screen) Surface and specify only the size,
letting it copy other properties (mainly the bit depth) from the window surface (<code>win</code>).</p>
<pre>
surf = Surface.new([51,71], win)
</pre>

<p>Then we blit (copy) a portion of the window contents to this new surface.
</p>
<pre>
surf.blit(win, [0,0], [70,30,51,71])
</pre>

<p>We create a mirrored copy of the surface with <code>mirror_x</code>, and blit that back to
the window next to the original picture. All this will result in a picture of a stupid-looking smiley.
</p>
<pre>
win.blit(surf.mirror_x, [121,30])
</pre>

<p>Again, none of our drawing operations are visible in the window until we call <code>update</code>.
After that we wait for the window to be closed.
</p>
<pre>
win.update

loop do
    event = EventQueue.wait
    break if event.is_a? QuitEvent
end
</pre>

<br>
<p>There! As you can see, drawing is very straightforward, and pretty much what you would
expect from an easy-to-use graphics library.
</p>



<h2>Input handling</h2>

<p>Now that we know how to draw graphics, it's time to learn about the input subsystem and
add interactivity to our programs.</p>

<p>Input can be handled in two ways: by receiving input events, or by reading the input
device's state. Input events are generated as the user does something: moves the mouse,
clicks mouse buttons, presses keys on the keyboard. These events are stored until your
program has time to handle them.</p>

<p>If you prefer not to work with events, you can read the current state of the keyboard and
mouse position with the Keyboard and Mouse classes. But if your program is delayed for any
reason, you can easily miss keypresses and mouse clicks with this method, since the user can
press and release a key or mouse button before you notice anything. Also, you will need to
clear the event queue anyway, otherwise the key and mouse states might not work reliably.
This is why events are the superior and preferred method.</p>


<h3>Receiving events</h3>

<p>Input events are objects of classes such as MouseMotionEvent, KeyDownEvent,
KeyUpEvent etc, which are all subclasses of Event. The EventQueue class provides class
methods to receive event objects.</p>

<p><code>EventQueue.wait</code> waits for an event to be received, and returns it. If
there already are pending events, it removes the first unprocessed event from the queue
and returns immediately. This is the method you should use if your program has nothing
to do while waiting for user input.</p>

<p>Let's examine the event handler we've been using so far:
</p>
<pre>
loop do
    event = EventQueue.wait
    break if event.is_a? QuitEvent
end
</pre>

<p>It waits for an event, and checks if its class is QuitEvent. They are triggered when the
user clicks the window close button, so if it was one, it exits the loop. There's no more code
so the program exits and the window is closed. Note that the window doesn't go anywhere
if we just ignore the QuitEvent.</p>


<p><code>EventQueue.get</code> returns an array of all pending events and returns
immediately. If there are no pending events it returns an empty array. This is the method
you should use for event handling if you cannot afford to halt the program until the next
input event is received (for example, if you're running an animation while waiting for input).</p>

<p>A word of warning about <code>EventQueue.poll</code>, which returns the first pending
event, or nil if there aren't any. You shouldn't just handle <i>one</i> event every now and
then, because the event queue can easily grow so long that it takes ages for the latest
ones to get processed. You should process <i>all</i> pending events every now and then,
and while it's perfectly possible with <code>EventQueue.poll</code>, it's easier and more
elegant to do:</p>

<pre>
EventQueue.get.each do |event|
    exit if event.is_a? QuitEvent
    # possibly handle other types
end
</pre>




<br><br><br><br><br><br><br><br><br><br><br><br>

</body>
</html>











<?xml version="1.0" ?>
<!DOCTYPE html 
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<link rel=stylesheet type='text/css' href='rudl.css'>
<title>rudl_video_surface</title>
</head>
<body>
<a href='index.html'>Back to index</a>
<h1>Index</h1>
<br><a href='rudl_video_surface.html#label-0'>Surface</a>
<br><a href='rudl_video_surface.html#label-1'>Class Methods</a>
<br><a href='rudl_video_surface.html#label-2'><code>Surface.new( <var>size</var> )</code></a>
<br><a href='rudl_video_surface.html#label-3'><code>Surface.new( <var>size</var>, <var>surface</var> )</code></a>
<br><a href='rudl_video_surface.html#label-4'><code>Surface.new( <var>size</var>, <var>flags</var> )</code></a>
<br><a href='rudl_video_surface.html#label-5'><code>Surface.new( <var>size</var>, <var>flags</var>, <var>surface</var> )</code></a>
<br><a href='rudl_video_surface.html#label-6'><code>Surface.new( <var>size</var>, <var>flags</var>, <var>depth</var> )</code></a>
<br><a href='rudl_video_surface.html#label-7'><code>Surface.new( <var>size</var>, <var>flags</var>, <var>depth</var>, <var>masks</var> )</code></a>
<br><a href='rudl_video_surface.html#label-8'><code>Surface.load_new( <var>filename</var> )</code></a>
<br><a href='rudl_video_surface.html#label-9'><code>String.to_surface</code></a>
<br><a href='rudl_video_surface.html#label-10'><code>Surface.shared_new( <var>surface</var> )</code></a>
<br><a href='rudl_video_surface.html#label-11'>Instance Methods</a>
<br><a href='rudl_video_surface.html#label-12'><code>Surface#share( <var>other_surface</var> )</code></a>
<br><a href='rudl_video_surface.html#label-13'><code>Surface#immodest_export( <var>other_surface</var> )</code></a>
<br><a href='rudl_video_surface.html#label-14'><code>Surface#destroy</code></a>
<br><a href='rudl_video_surface.html#label-15'><code>Surface#blit( <var>source</var>, <var>coordinate</var> )</code></a>
<br><a href='rudl_video_surface.html#label-16'><code>Surface#blit( <var>source</var>, <var>coordinate</var>, <var>sourceRect</var> )</code></a>
<br><a href='rudl_video_surface.html#label-17'><code>Surface#convert</code></a>
<br><a href='rudl_video_surface.html#label-18'><code>Surface#convert_alpha</code></a>
<br><a href='rudl_video_surface.html#label-19'><code>Surface#convert!</code></a>
<br><a href='rudl_video_surface.html#label-20'><code>Surface#convert_alpha!</code></a>
<br><a href='rudl_video_surface.html#label-21'><code>Surface#lock</code></a>
<br><a href='rudl_video_surface.html#label-22'><code>Surface#must_lock</code></a>
<br><a href='rudl_video_surface.html#label-23'><code>Surface#unlock</code></a>
<br><a href='rudl_video_surface.html#label-24'><code>Surface#locked?</code></a>
<br><a href='rudl_video_surface.html#label-25'><code>Surface#save_bmp( <var>filename</var> )</code></a>
<br><a href='rudl_video_surface.html#label-26'><code>Surface#w</code></a>
<br><a href='rudl_video_surface.html#label-27'><code>Surface#h</code></a>
<br><a href='rudl_video_surface.html#label-28'><code>Surface#size</code></a>
<br><a href='rudl_video_surface.html#label-29'><code>Surface#rect</code></a>
<br><a href='rudl_video_surface.html#label-30'><code>Surface#colorkey</code></a>
<br><a href='rudl_video_surface.html#label-31'><code>Surface#unset_colorkey</code></a>
<br><a href='rudl_video_surface.html#label-32'><code>Surface#set_colorkey( <var>color</var> )</code></a>
<br><a href='rudl_video_surface.html#label-33'><code>Surface#set_colorkey( <var>color</var>, <var>flags</var> )</code></a>
<br><a href='rudl_video_surface.html#label-34'><code>Surface#fill( <var>color</var> )</code></a>
<br><a href='rudl_video_surface.html#label-35'><code>Surface#fill( <var>color</var>, <var>rect</var> )</code></a>
<br><a href='rudl_video_surface.html#label-36'><code>Surface#pitch</code></a>
<br><a href='rudl_video_surface.html#label-37'><code>Surface#bitsize</code></a>
<br><a href='rudl_video_surface.html#label-38'><code>Surface#bytesize</code></a>
<br><a href='rudl_video_surface.html#label-39'><code>Surface#flags</code></a>
<br><a href='rudl_video_surface.html#label-40'><code>Surface#losses</code></a>
<br><a href='rudl_video_surface.html#label-41'><code>Surface#shifts</code></a>
<br><a href='rudl_video_surface.html#label-42'><code>Surface#masks</code></a>
<br><a href='rudl_video_surface.html#label-43'><code>Surface#palette</code></a>
<br><a href='rudl_video_surface.html#label-44'><code>Surface#set_palette( <var>first</var>, <var>colors</var> )</code></a>
<br><a href='rudl_video_surface.html#label-45'><code>Surface#alpha</code></a>
<br><a href='rudl_video_surface.html#label-46'><code>Surface#unset_alpha</code></a>
<br><a href='rudl_video_surface.html#label-47'><code>Surface#set_alpha( <var>alpha</var> )</code></a>
<br><a href='rudl_video_surface.html#label-48'><code>Surface#set_alpha( <var>alpha</var>, <var>flags</var> )</code></a>
<br><a href='rudl_video_surface.html#label-49'><code>Surface#clip</code></a>
<br><a href='rudl_video_surface.html#label-50'><code>Surface#unset_clip</code></a>
<br><a href='rudl_video_surface.html#label-51'><code>Surface#clip=( <var>rect</var> )</code></a>
<br><a href='rudl_video_surface.html#label-52'><code>Surface#contained_images</code></a>
<br><a href='rudl_video_surface.html#label-53'><code>Surface#get( <var>coordinate</var> )</code></a>
<br><a href='rudl_video_surface.html#label-54'><code>Surface#[ <var>x</var>, <var>y</var> ]</code></a>
<br><a href='rudl_video_surface.html#label-55'><code>Surface#rows</code></a>
<br><a href='rudl_video_surface.html#label-56'><code>Surface#get_row( <var>y</var> )</code></a>
<br><a href='rudl_video_surface.html#label-57'><code>Surface#set_row( <var>y</var>, <var>pixels</var> )</code></a>
<br><a href='rudl_video_surface.html#label-58'><code>Surface#each_row { |<var>row_of_pixels</var>| ... }</code></a>
<br><a href='rudl_video_surface.html#label-59'><code>Surface#each_row! { |<var>row_of_pixels</var>| ... }</code></a>
<br><a href='rudl_video_surface.html#label-60'><code>Surface#columns</code></a>
<br><a href='rudl_video_surface.html#label-61'><code>Surface#get_column( <var>x</var> )</code></a>
<br><a href='rudl_video_surface.html#label-62'><code>Surface#set_column( <var>x</var>, <var>pixels</var> )</code></a>
<br><a href='rudl_video_surface.html#label-63'><code>Surface#each_column { |<var>column_of_pixels</var>| ... }</code></a>
<br><a href='rudl_video_surface.html#label-64'><code>Surface#each_column! { |<var>column_of_pixels</var>| ... }</code></a>
<br><a href='rudl_video_surface.html#label-65'><code>Surface#pixels</code></a>
<br><a href='rudl_video_surface.html#label-66'><code>Surface#pixels=( <var>pixeldata</var> )</code></a>


<h1><a name="label-0" id="label-0">Surface</a></h1><!-- RDLabel: "Surface" -->
<p>A <code>Surface</code> is a two dimensional array of pixels with some information about those pixels.
This might not seem like much, but it is just about the most important class in RUDL.</p>
<h2><a name="label-1" id="label-1">Class Methods</a></h2><!-- RDLabel: "Class Methods" -->
<dl>
<dt><a name="label-2" id="label-2"><code>Surface.new( <var>size</var> )</code></a></dt><!-- RDLabel: "Surface.new" -->
<dt><a name="label-3" id="label-3"><code>Surface.new( <var>size</var>, <var>surface</var> )</code></a></dt><!-- RDLabel: "Surface.new" -->
<dt><a name="label-4" id="label-4"><code>Surface.new( <var>size</var>, <var>flags</var> )</code></a></dt><!-- RDLabel: "Surface.new" -->
<dt><a name="label-5" id="label-5"><code>Surface.new( <var>size</var>, <var>flags</var>, <var>surface</var> )</code></a></dt><!-- RDLabel: "Surface.new" -->
<dt><a name="label-6" id="label-6"><code>Surface.new( <var>size</var>, <var>flags</var>, <var>depth</var> )</code></a></dt><!-- RDLabel: "Surface.new" -->
<dt><a name="label-7" id="label-7"><code>Surface.new( <var>size</var>, <var>flags</var>, <var>depth</var>, <var>masks</var> )</code></a></dt><!-- RDLabel: "Surface.new" -->
</dl>
<p>All these methods create a new <code>Surface</code> with <var>size</var> = [w, h].
If only <var>size</var> is supplied, the rest of the arguments will be set to reasonable values.
If a surface is supplied, it is used to copy the values from that aren't given.</p>
<p><var>flags</var> is, quoted from SDL's documentation:</p>
<ul>
<li>SWSURFACE: SDL will create the surface in system memory. This improves the performance of pixel level access, however you may not be able to take advantage of some types of hardware blitting.</li>
<li>HWSURFACE: SDL will attempt to create the surface in video memory. This will allow SDL to take advantage of Video-&gt;Video blits (which are often accelerated).</li>
<li>SRCCOLORKEY: This flag turns on colourkeying for blits from this surface. If SDL_HWSURFACE is also specified and colourkeyed blits are hardware-accelerated, then	SDL will attempt to place the surface in video memory. Use SDL_SetColorKey to set or clear this flag after surface creation.</li>
<li>SRCALPHA: This flag turns on alpha-blending for blits from this surface. If SDL_HWSURFACE	is also specified and alpha-blending blits are hardware-accelerated, then the surface	will be placed in video memory if possible. Use SDL_SetAlpha to set or clear this flag	after surface creation. For a 32 bitdepth surface, an alpha mask will automatically be	added, in other cases, you will have to specify a mask.</li>
</ul>
<p><var>depth</var> is bitdepth, like 8, 15, 16, 24 or 32.</p>
<p><var>masks</var> describes the format for the pixels and is an array of [R, G, B, A]
containing 32 bit values with bits set where the colorcomponent should be stored.
For example: [0xFF000000, 0x00FF0000, 0x0000FF00, 0x000000FF] describes a 32 bit color
with red in the highest values and an alpha channel. If it is not specified, the following
defaults are used:</p>
<p>RRGGGBB (8bpp)</p>
<p>RRRR GGGGBBBB (12bpp)</p>
<p>RRRRRGG GGGBBBBB (15bpp)</p>
<p>RRRRRGGG GGGBBBBB (16bpp)</p>
<p>RRRRRRRR GGGGGGGG BBBBBBBB (24 bpp)</p>
<p>........ RRRRRRRR GGGGGGGG BBBBBBBB (32 bpp)</p>
<p>RRRRRRRR GGGGGGGG BBBBBBBB AAAAAAAA (32 bpp, SRCALPHA set)</p>
<p>Normally this shouldn't have to be of interest.</p>
<dl>
<dt><a name="label-8" id="label-8"><code>Surface.load_new( <var>filename</var> )</code></a></dt><!-- RDLabel: "Surface.load_new" -->
<dt><a name="label-9" id="label-9"><code>String.to_surface</code></a></dt><!-- RDLabel: "String.to_surface" -->
</dl>
<p>This creates a <code>Surface</code> with an image in it,
loaded from disk from <var>filename</var> by using load_new
or loaded by treating <var>String</var> as the image data when using to_surface.
In the last case, the <var>string</var> should be in some supported format,
just like the file for load_new should be.
If the SDL_image library was found during RUDL's installation,
it will load the following formats:
BMP, PNM, XPM, XCF, PCX, GIF, JPEG, TIFF, PNG, TGA and LBM.
If the SDL_image library was not found, only simple BMP loading is supported.
Simple means: not all BMP files can be loaded.</p>
<dl>
<dt><a name="label-10" id="label-10"><code>Surface.shared_new( <var>surface</var> )</code></a></dt><!-- RDLabel: "Surface.shared_new" -->
</dl>
<p>This method is two things:</p>
<ol>
<li>a way to share the same bunch of data (width, height, bpp, pixeldata) between two Surface objects. Please don't use it this way if there isn't a very good reason for it.</li>
<li>a way to import foreign objects that wrap an SDL_Surface*. If that doesn't mean anything to you, please ignore this point. It takes the pointer from the foreign object and creates a new Surface that wraps it.</li>
</ol>
<p>Garbage collection problems should be prevented by giving the new surface
a reference to <var>surface</var></p>
<p>Note that if the original surface is destroyed by a call to Surface#destroy,
the shared ones will be invalidated too!</p>
<h2><a name="label-11" id="label-11">Instance Methods</a></h2><!-- RDLabel: "Instance Methods" -->
<dl>
<dt><a name="label-12" id="label-12"><code>Surface#share( <var>other_surface</var> )</code></a></dt><!-- RDLabel: "Surface#share" -->
</dl>
<p>Like Surface.shared_new, but this works on an existing surface.
It will destroy this surface, then make it share <var>other_surface</var>'s data.</p>
<p>Returns self.</p>
<dl>
<dt><a name="label-13" id="label-13"><code>Surface#immodest_export( <var>other_surface</var> )</code></a></dt><!-- RDLabel: "Surface#immodest_export" -->
</dl>
<p>Like Surface.share, but this works the other way around.
It will destroy the <var>other_surface</var>, then make it share the data in itself
and setting a reference on <var>other_surface</var> back to <var>self</var>.
It's called immodest because it interferes with another object, bluntly
assuming it contains a SDL_Surface pointer and changing it to something
else...</p>
<p>Returns self.</p>
<dl>
<dt><a name="label-14" id="label-14"><code>Surface#destroy</code></a></dt><!-- RDLabel: "Surface#destroy" -->
</dl>
<p>Frees memory used by this surface.
The surface is no longer useable after this call.</p>
<p>Returns nil.</p>
<dl>
<dt><a name="label-15" id="label-15"><code>Surface#blit( <var>source</var>, <var>coordinate</var> )</code></a></dt><!-- RDLabel: "Surface#blit" -->
<dt><a name="label-16" id="label-16"><code>Surface#blit( <var>source</var>, <var>coordinate</var>, <var>sourceRect</var> )</code></a></dt><!-- RDLabel: "Surface#blit" -->
</dl>
<p>This method blits (copies, pastes, draws) <var>source</var> onto the <code>Surface</code> it is called on.
<var>coordinate</var> is the position [x, y] where <var>source</var> will end up in the destination <code>Surface</code>.
<var>sourcerect</var> is the area in the <var>source</var> bitmap that you want blitted.
Not supplying it will blit the whole <var>source</var>.</p>
<p>Returns the rectangle array ([x,y,w,h]) in <code>Surface</code> that was changed.</p>
<dl>
<dt><a name="label-17" id="label-17"><code>Surface#convert</code></a></dt><!-- RDLabel: "Surface#convert" -->
<dt><a name="label-18" id="label-18"><code>Surface#convert_alpha</code></a></dt><!-- RDLabel: "Surface#convert_alpha" -->
</dl>
<p>Creates a new version of the surface in the current display's format,
making it faster to blit.
The alpha version optimizes for fast alpha blitting.</p>
<p>Returns the converted surface.</p>
<dl>
<dt><a name="label-19" id="label-19"><code>Surface#convert!</code></a></dt><!-- RDLabel: "Surface#convert!" -->
<dt><a name="label-20" id="label-20"><code>Surface#convert_alpha!</code></a></dt><!-- RDLabel: "Surface#convert_alpha!" -->
</dl>
<p>Like convert and convert_alpha, but these change the surface itself.</p>
<p>Returns self.</p>
<dl>
<dt><a name="label-21" id="label-21"><code>Surface#lock</code></a></dt><!-- RDLabel: "Surface#lock" -->
<dt><a name="label-22" id="label-22"><code>Surface#must_lock</code></a></dt><!-- RDLabel: "Surface#must_lock" -->
<dt><a name="label-23" id="label-23"><code>Surface#unlock</code></a></dt><!-- RDLabel: "Surface#unlock" -->
<dt><a name="label-24" id="label-24"><code>Surface#locked?</code></a></dt><!-- RDLabel: "Surface#locked?" -->
</dl>
<p>These methods control the locking of surfaces.
If you ever encounter a locking error,
you might try these out.
Locking errors are expected when trying to access video hardware.
Keep <code>Surface</code>s locked for as short a time as possible.</p>
<ul>
<li>must_lock returns true when a surface needs locking for pixel access.</li>
<li>lock locks the surface and returns self.</li>
<li>unlock unlocks it again and returns self.</li>
<li>locked? returns true when the surface is locked.</li>
</ul>
<dl>
<dt><a name="label-25" id="label-25"><code>Surface#save_bmp( <var>filename</var> )</code></a></dt><!-- RDLabel: "Surface#save_bmp" -->
</dl>
<p>This is the only method in RUDL which stores surface data.
Pass <var>save_bmp</var> the <var>filename</var> and the surface data will be saved to that file.
It returns self.</p>
<dl>
<dt><a name="label-26" id="label-26"><code>Surface#w</code></a></dt><!-- RDLabel: "Surface#w" -->
<dt><a name="label-27" id="label-27"><code>Surface#h</code></a></dt><!-- RDLabel: "Surface#h" -->
<dt><a name="label-28" id="label-28"><code>Surface#size</code></a></dt><!-- RDLabel: "Surface#size" -->
<dt><a name="label-29" id="label-29"><code>Surface#rect</code></a></dt><!-- RDLabel: "Surface#rect" -->
</dl>
<p>These methods return the size of the surface.
w returns width,
h returns height,
size returns [w, h] and rect returns an array of [0, 0, w, h].</p>
<dl>
<dt><a name="label-30" id="label-30"><code>Surface#colorkey</code></a></dt><!-- RDLabel: "Surface#colorkey" -->
<dt><a name="label-31" id="label-31"><code>Surface#unset_colorkey</code></a></dt><!-- RDLabel: "Surface#unset_colorkey" -->
<dt><a name="label-32" id="label-32"><code>Surface#set_colorkey( <var>color</var> )</code></a></dt><!-- RDLabel: "Surface#set_colorkey" -->
<dt><a name="label-33" id="label-33"><code>Surface#set_colorkey( <var>color</var>, <var>flags</var> )</code></a></dt><!-- RDLabel: "Surface#set_colorkey" -->
</dl>
<p>These methods control the color that will be completely transparent (it will not be copied
to the destination surface.)
The only flag is "RLEACCEL" which will encode the bitmap in a more efficient way for blitting,
by skipping the transparent pixels.</p>
<p><var>colorkey</var> returns the current colorkey color.
The others return self;</p>
<dl>
<dt><a name="label-34" id="label-34"><code>Surface#fill( <var>color</var> )</code></a></dt><!-- RDLabel: "Surface#fill" -->
<dt><a name="label-35" id="label-35"><code>Surface#fill( <var>color</var>, <var>rect</var> )</code></a></dt><!-- RDLabel: "Surface#fill" -->
</dl>
<p>Fills rectangle <var>rect</var> in the surface with <var>color</var>.</p>
<p>Returns self.</p>
<dl>
<dt><a name="label-36" id="label-36"><code>Surface#pitch</code></a></dt><!-- RDLabel: "Surface#pitch" -->
</dl>
<p>The surface pitch is the number of bytes used in each scanline.
This function should rarely needed, mainly for any special-case debugging.</p>
<dl>
<dt><a name="label-37" id="label-37"><code>Surface#bitsize</code></a></dt><!-- RDLabel: "Surface#bitsize" -->
</dl>
<p>Returns the number of bits used to represent each pixel.
This value may not exactly fill the number of bytes used per pixel.
For example a 15 bit Surface still requires a full 2 bytes.</p>
<dl>
<dt><a name="label-38" id="label-38"><code>Surface#bytesize</code></a></dt><!-- RDLabel: "Surface#bytesize" -->
</dl>
<p>Returns the number of bytes used to store each pixel.</p>
<dl>
<dt><a name="label-39" id="label-39"><code>Surface#flags</code></a></dt><!-- RDLabel: "Surface#flags" -->
</dl>
<p>Returns the current state flags for the surface.</p>
<dl>
<dt><a name="label-40" id="label-40"><code>Surface#losses</code></a></dt><!-- RDLabel: "Surface#losses" -->
</dl>
<p>Returns the bitloss for each color plane.
The loss is the number of bits removed for each colorplane from a full 8 bits of
resolution. A value of 8 usually indicates that colorplane is not used
(like the alpha)</p>
<p>Returns an array of [redloss, greenloss, blueloss, alphaloss]</p>
<dl>
<dt><a name="label-41" id="label-41"><code>Surface#shifts</code></a></dt><!-- RDLabel: "Surface#shifts" -->
</dl>
<p>Returns the bitshifts [redshift, greenshift, blueshift, alphashift] used for each color plane.
The shift is determine how many bits left-shifted a colorplane value is in a
mapped color value.</p>
<dl>
<dt><a name="label-42" id="label-42"><code>Surface#masks</code></a></dt><!-- RDLabel: "Surface#masks" -->
</dl>
<p>Returns the bitmasks [redmask, greenmask, bluemask, alphamask] for each color plane.
The bitmask is used to isolate each colorplane value from a mapped color value.
A value of zero means that colorplane is not used (like alpha)</p>
<dl>
<dt><a name="label-43" id="label-43"><code>Surface#palette</code></a></dt><!-- RDLabel: "Surface#palette" -->
<dt><a name="label-44" id="label-44"><code>Surface#set_palette( <var>first</var>, <var>colors</var> )</code></a></dt><!-- RDLabel: "Surface#set_palette" -->
</dl>
<p>These methods return or set the 256 color palette that is part of 8 bit <code>Surface</code>s.
<var>first</var> is the first color to change.
<var>colors</var> and the return value of <var>palette</var> are arrays of colors like
[[50,80,120], [255,255,0]]</p>
<dl>
<dt><a name="label-45" id="label-45"><code>Surface#alpha</code></a></dt><!-- RDLabel: "Surface#alpha" -->
<dt><a name="label-46" id="label-46"><code>Surface#unset_alpha</code></a></dt><!-- RDLabel: "Surface#unset_alpha" -->
<dt><a name="label-47" id="label-47"><code>Surface#set_alpha( <var>alpha</var> )</code></a></dt><!-- RDLabel: "Surface#set_alpha" -->
<dt><a name="label-48" id="label-48"><code>Surface#set_alpha( <var>alpha</var>, <var>flags</var> )</code></a></dt><!-- RDLabel: "Surface#set_alpha" -->
</dl>
<p>Gets or sets the overall transparency for the <code>Surface</code>.
An <var>alpha</var> of 0 is fully transparent, an <var>alpha</var> of 255 is fully opaque.
If your surface has a pixel alpha channel, it will override the overall surface transparency.
You'll need to change the actual pixel transparency to make changes.
If your image also has pixel alpha values and will be used repeatedly, you
will probably want to pass the <var>RLEACCEL</var> flag to the call.
This will take a short time to compile your surface, and increase the blitting speed.</p>
<dl>
<dt><a name="label-49" id="label-49"><code>Surface#clip</code></a></dt><!-- RDLabel: "Surface#clip" -->
<dt><a name="label-50" id="label-50"><code>Surface#unset_clip</code></a></dt><!-- RDLabel: "Surface#unset_clip" -->
<dt><a name="label-51" id="label-51"><code>Surface#clip=( <var>rect</var> )</code></a></dt><!-- RDLabel: "Surface#clip=" -->
</dl>
<p>Retrieves, removes or sets the clipping rectangle for surfaces that are
blitted to this surface.</p>
<dl>
<dt><a name="label-52" id="label-52"><code>Surface#contained_images</code></a></dt><!-- RDLabel: "Surface#contained_images" -->
</dl>
<p>Returns an array of surfaces that are found by parsing this surface in a certain way.
An example is in the samples directory, in crapola.rbw.
This is not part of SDL, it is RUDL-specific.</p>
<dl>
<dt><a name="label-53" id="label-53"><code>Surface#get( <var>coordinate</var> )</code></a></dt><!-- RDLabel: "Surface#get" -->
<dt><a name="label-54" id="label-54"><code>Surface#[ <var>x</var>, <var>y</var> ]</code></a></dt><!-- RDLabel: "Surface#[ x, y ]" -->
</dl>
<p>These methods read single pixels on a surface.
<var>get</var> or <var>[]</var> get the color of a pixel.
These methods require the surface to be locked if neccesary.
<var>[]=</var> and <var>[]</var> are the only methods in RUDL that take a seperate <var>x</var> and <var>y</var> coordinate.</p>
<dl>
<dt><a name="label-55" id="label-55"><code>Surface#rows</code></a></dt><!-- RDLabel: "Surface#rows" -->
<dt><a name="label-56" id="label-56"><code>Surface#get_row( <var>y</var> )</code></a></dt><!-- RDLabel: "Surface#get_row" -->
<dt><a name="label-57" id="label-57"><code>Surface#set_row( <var>y</var>, <var>pixels</var> )</code></a></dt><!-- RDLabel: "Surface#set_row" -->
<dt><a name="label-58" id="label-58"><code>Surface#each_row { |<var>row_of_pixels</var>| ... }</code></a></dt><!-- RDLabel: "Surface#each_row" -->
<dt><a name="label-59" id="label-59"><code>Surface#each_row! { |<var>row_of_pixels</var>| ... }</code></a></dt><!-- RDLabel: "Surface#each_row!" -->
</dl>
<p>These methods manipulate rows of pixels.
<code>Surface</code>#<var>rows</var> returns an array of strings with one row of imagedata each.
<var>get_row</var> and <var>set_row</var> get and set a single such row.
<var>each_row</var> and <var>each_row!</var> iterate through the rows,
passing each of them to the supplied codeblock.
For more info, see <code>Surface</code>#<var>pixels</var>.</p>
<dl>
<dt><a name="label-60" id="label-60"><code>Surface#columns</code></a></dt><!-- RDLabel: "Surface#columns" -->
<dt><a name="label-61" id="label-61"><code>Surface#get_column( <var>x</var> )</code></a></dt><!-- RDLabel: "Surface#get_column" -->
<dt><a name="label-62" id="label-62"><code>Surface#set_column( <var>x</var>, <var>pixels</var> )</code></a></dt><!-- RDLabel: "Surface#set_column" -->
<dt><a name="label-63" id="label-63"><code>Surface#each_column { |<var>column_of_pixels</var>| ... }</code></a></dt><!-- RDLabel: "Surface#each_column" -->
<dt><a name="label-64" id="label-64"><code>Surface#each_column! { |<var>column_of_pixels</var>| ... }</code></a></dt><!-- RDLabel: "Surface#each_column!" -->
</dl>
<p>These methods manipulate columns of pixels.
<code>Surface</code>#<var>columns</var> returns an array of strings with one column of imagedata each.
<var>get_column</var> and <var>set_column</var> get and set a single such column.
<var>each_column</var> and <var>each_column!</var> iterate through the columns,
passing each of them to the supplied codeblock.
For more info, see <code>Surface</code>#<var>pixels</var>.</p>
<dl>
<dt><a name="label-65" id="label-65"><code>Surface#pixels</code></a></dt><!-- RDLabel: "Surface#pixels" -->
<dt><a name="label-66" id="label-66"><code>Surface#pixels=( <var>pixeldata</var> )</code></a></dt><!-- RDLabel: "Surface#pixels=" -->
</dl>
<p>These methods get and set all image data at once.
The transport medium is a string with binary data in it.
The data is raw, no fancy color arrays here.
If bytesize (the amount of bytes used to describe the color of a pixel) is
four, for example, a <code>Surface</code> of 5x5 pixels will return a string of length (5x5x4).
If the colorformat is specified as BGRA, then character zero will be the
B component, character one the G component etc.
Eight bit color surfaces store one byte indexes into the palette.
These methods perform best when the surface's pitch is equal to its width.
There is not much errorchecking so beware of crashes.</p>

<a href='index.html'>Back to index</a>
</body>
</html>